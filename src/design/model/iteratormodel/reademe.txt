迭代子模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation）。
迭代子模式有两种实现方式，分别是白箱聚集与外禀迭代子和黑箱聚集于内禀迭代子。
白箱聚集与外禀迭代子
　　如果一个聚集的接口提供了可以用来修改聚集元素的方法，这个接口就是所谓的宽接口。

　　如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求。但是，这样会破坏对聚集对象的封装。
这种提供宽接口的聚集叫做白箱聚集。聚集对象向外界提供同样的宽接口
由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代
子叫做游标迭代子（Cursor Iterator）。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做外禀迭代子（Extrinsic Iterator）。
迭代子模式涉及到以下几个角色：

　　●抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。
　　●具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。
　　●聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。
　　●具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。
　　●客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。

源代码:
包one是白箱聚集与外禀迭代子的实现例子
包two是黑箱聚集与内禀迭代子的实现例子

主动迭代子和被动迭代子
　　主动迭代子和被动迭代子又称作外部迭代子和内部迭代子。
　　所谓主动（外部）迭代子，指的是由客户端来控制迭代下一个元素的步骤，客户端会明显调用迭代子的next()等迭代方法，在遍历过程中向前进行。
　　所谓被动（内部）迭代子，指的是由迭代子自己来控制迭代下一个元素的步骤。因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传递给迭代子，
迭代子在迭代的时候会在每个元素上执行这个操作，类似于JAVA的回调机制。
　　总体来说外部迭代器比内部迭代器要灵活一些，因此我们常见的实现多属于主动迭代子。

静态迭代子和动态迭代子
　　●静态迭代子由聚集对象创建，并持有聚集对象的一份快照(snapshot)，在产生后这个快照的内容就不再变化。客户端可以继续修改原聚集的内容，
但是迭代子对象不会反映出聚集的新变化。
　　静态迭代子的好处是它的安全性和简易性，换言之，静态迭代子易于实现，不容易出现错误。但是由于静态迭代子将原聚集复制了一份，因此它的短处是对时间和内存资源的消耗。
　　●动态迭代子则与静态迭代子完全相反，在迭代子被产生之后，迭代子保持着对聚集元素的引用，因此，任何对原聚集内容的修改都会在迭代子对象上反映出来。
　　完整的动态迭代子不容易实现，但是简化的动态迭代子并不难实现。大多数JAVA设计师遇到的迭代子都是这种简化的动态迭代子。为了说明什么是简化的动态迭代子，
首先需要介绍一个新的概念：Fail Fast。
Fail Fast
　　如果一个算法开始之后，它的运算环境发生变化，使得算法无法进行必需的调整时，这个算法就应当立即发出故障信号。这就是Fail Fast的含义。
　　如果聚集对象的元素在一个动态迭代子的迭代过程中发生变化时，迭代过程会受到影响而变得不能自恰。这时候，迭代子就应当立即抛出一个异常。这种迭代子就是实现了Fail Fast功能的迭代子。
Fail Fast在JAVA聚集中的使用
　　JAVA语言以接口java.util.Iterator的方式支持迭代子模式，Collection接口要求提供iterator()方法，此方法在调用时返还一个Iterator类型的对象。而作为Collection接口的子类型，
AbstractList类的内部成员类Itr便是实现Iterator接口的类。